namespace OVSXmlSerializer.Internals
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Runtime.InteropServices;
	using System.Text;
	using System.Xml;
	using System.Xml.Linq;
	using System.Xml.Serialization;

	/// <summary>
	/// 
	/// </summary>
	/// <remarks>
	/// Not thread safe if you want to use the writer for multiple serializers; 
	/// uses quite a bit of global variables.
	/// </remarks>
	/// <typeparam name="T"></typeparam>
	public class OVSXmlWriter<T>
	{
		/// <summary>
		/// Throws an exception if the specified type does not have a parameterless
		/// constructor. Otherwise does nothing.
		/// </summary>
		/// <param name="type"> The type to check if it has one. </param>
		internal void EnsureParameterlessConstructor(Type type)
		{
			if (type.GetConstructor(OVSXmlSerializer.defaultFlags, null, Array.Empty<Type>(), null) == null && type.IsClass)
			{
				string message = $"{type.Name} does not have an empty constructor!";
				throw new NullReferenceException(message);
			}
		}

		public XmlDocument Document { get; private set; }
		public OVSXmlSerializer<T> Source { get; }
		public OVSConfig Config => Source.Config;
		internal OVSXmlReferencer Referencer { get; private set; }

		/// <summary>
		/// Reads out all warnings that are not exceptions as a string.
		/// </summary>
		public string Logs => warnings.ToString();
		private StringBuilder warnings;
		public OVSXmlWriter(OVSXmlSerializer<T> source)
		{
			warnings = new StringBuilder();
			this.Source = source;
		}

		/// <summary>
		/// Serializes a single object into a xml file, using <see cref="Document"/>
		/// as to save its changes.
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="name"></param>
		/// <returns><see cref="Document"/></returns>
		/// <exception cref="Exception"></exception>
		public XmlDocument SerializeObject(in T obj, string name)
		{
			Document = new XmlDocument();
			if (Source.Config.UseSingleInstanceInsteadOfMultiple)
				Referencer = new OVSXmlReferencer(Document, Config);
			else
				Referencer = null; 
			Type startingType = typeof(object); 
			Type[] genericTypes = Source.GetType().GetGenericArguments();
			if (genericTypes.Length > 0)
				startingType = genericTypes[0];
			var structuredObject = new StructuredObject(obj, startingType);
			warnings.Clear();
			try
			{
				if (!structuredObject.IsNull)
				{
					if (!Config.OmitAutoGenerationComment)
						Document.AppendChild(Document.CreateComment("Auto-generated by OVSXmlSerializer"));
					WriteObject(structuredObject, Document, StructuredObject.EnsureName(name, structuredObject));
					// Then write version number if enabled
					if (!Config.AsWriterSettings().OmitXmlDeclaration)
					{
						XmlNode explanationNode = Document.FirstChild;
						XmlAttribute versionAttribute = explanationNode.Attributes.GetNamedItem(Versioning.VERSION_NAME) as XmlAttribute;
						versionAttribute.Value = Config.Version.ToString();
					}
				}
				return Document;
			}
			catch (Exception ex)
			{
				throw new Exception($"Failed to serialize object type '{obj.GetType().FullName}' named {name}.", ex);
			}
		}
		/// <summary>
		/// Writes an object, goes through the checklist:
		/// <list type="number">
		/// <item>The <see cref="IOVSXmlSerializable"/> interface, assuming <see cref="IOVSXmlSerializable.ShouldWrite"/> is true.</item>
		/// <item>Serializing it as a reference.</item>
		/// </list>
		/// </summary>
		/// <param name="obj">The object to serialize to.</param>
		/// <param name="parent">The parent of the object.</param>
		/// <param name="name">The name of the element or attribute.</param>
		/// <param name="forceNormalSerialize">If it ignores all the extras and just serializes the fields, useful for external serializers.</param>
		/// <exception cref="Exception"></exception>
		/// <exception cref="InvalidOperationException"></exception>
		/// <exception cref="InvalidCastException"></exception>
		public void WriteObject(StructuredObject obj, XmlNode parent, string name, bool forceNormalSerialize = false)
		{
			if (obj.IsNull)
				return;
			if (XmlIgnoreAttribute.Ignore(obj))
				return;
			if (obj.Value is IOVSXmlSerializable serializable)
			{
				// Not sure how the actual scheme works at all since I never used
				// - one. I don't this applies here at all anyways.
				if (serializable.ShouldWrite == false)
					return;
				EnsureParameterlessConstructor(obj.ValueType);
				XmlElement serializableElement = CreateElement(parent, name);
				serializable.Write(Document, serializableElement);
				return;
			}
			if (obj.Value is Delegate)
				return;



			if (ReferenceType(name, obj, parent))
				return;
			if (TryWriteEnum(name, obj, parent))
				return;
			if (TryWritePrimitive(name, obj, parent))
				return;
			if (XmlAttributeAttribute.IsAttribute(obj, out _)) // Not primitive, but struct or class
				throw new Exception($"{obj.Value} is not a primitive type!");
			if (TryWriteEnumerable(name, obj, parent))
				return;

			EnsureParameterlessConstructor(obj.ValueType);
			XmlNode currentNode = CreateElement(parent, name, obj);

			FieldInfo[] infos = obj.ValueType.GetFields(OVSXmlSerializer.defaultFlags);

			bool didText = false;
			bool hasElements = false;
			for (int i = 0; i < infos.Length; i++)
			{
				FieldInfo field = infos[i];
				FieldObject fieldObject = new FieldObject(field, obj.Value);
				if (field.IsInitOnly && !(obj is EnumeratedObject))
					switch (config.HandleReadonlyFields)
					{
						case ReadonlyFieldHandle.Ignore:
							continue;
						case ReadonlyFieldHandle.ThrowError:
							throw new InvalidOperationException($"{field.Name} from {obj.ValueType.Name} is readonly!");
						case ReadonlyFieldHandle.Continue:
							break;
					}
				// Doing ignore again for compatibility with text attribute
				if (XmlIgnoreAttribute.Ignore(field))
				{
					continue;
				}

				if (XmlTextAttribute.IsText(field))
				{
					if (didText)
						throw new InvalidOperationException($"There can only be one [{nameof(XmlText)}]!");
					if (hasElements)
						throw new InvalidOperationException($"There are elements in the field in {obj.Value}, be sure to ignore or put them as attributes!");
					didText = true;
					if (!TryWritePrimitive(ref currentNode, fieldObject, parent))
						throw new InvalidCastException();
					continue;
				}
				if (XmlAttributeAttribute.IsAttribute(field, out var contents))
				{
					WriteObject(fieldObject, currentNode, EnsureName(field.Name, fieldObject));
					continue;
				}
				if (didText)
					throw new Exception();
				hasElements = true;
				WriteObject(fieldObject, currentNode, EnsureName(field.Name, fieldObject));
			}
		}


		internal bool ReferenceType(in string name, StructuredObject obj, XmlNode parent)
		{
			if (!Config.UseSingleInstanceInsteadOfMultiple)
				return false;
			throw new NotImplementedException();
			if (OVSXmlReferencer.CanReference(obj) == false)
				return false;
			if (Referencer.IsAlreadyReferenced(obj, out int indexID))
			{
				XmlElement referenceElement = CreateElement(parent, $"Reference_{name}");
				referenceElement.InnerText = indexID.ToString();
				return true;
			}
			return false;
		}
		internal bool TryWriteEnum(in string name, StructuredObject @enum, XmlNode parent)
		{
			if (!@enum.ValueType.IsEnum)
				return false;
			XmlElement element = CreateElement(parent, name, @enum);
			element.InnerText = @enum.Value.ToString();
			return true;
		}
		internal bool TryWritePrimitive(string name, StructuredObject primitive, XmlNode parent)
		{
			if (!primitive.IsPrimitive)
				return false;
			if (XmlAttributeAttribute.IsAttribute(primitive, out var attribute))
			{
				if (XmlNamedAsAttribute.HasName(primitive, out string namedAs))
					name = namedAs;
				if (!string.IsNullOrEmpty(attribute.CustomName))
					name = attribute.CustomName;
				if (primitive is FieldObject fieldObj && fieldObj.IsDerivedFromBase)
					throw new Exception($"Cannot serialize {name} as the field " +
						"type doesn't match the object type. This is typically " +
						"caused as the primitive value is derived off of object " +
						"in an XML Attribute, unable to write the derived attribute " +
						"type.");
				XmlAttribute xmlAttribute = CreateAttribute(parent, name, ToStringPrimitive(primitive.Value));
				return true;
			}
			XmlNode currentNode = CreateElement(parent, name, primitive);
			currentNode.InnerText = ToStringPrimitive(primitive.Value);
			return true;
		}
		internal bool TryWritePrimitive(ref XmlNode currentNode, StructuredObject primitive, XmlNode parent)
		{
			if (!IsPrimitive(primitive))
				return false;
			if (XmlAttributeAttribute.IsAttribute(primitive, out var attribute))
			{
				if (!(currentNode is XmlAttribute))
					throw new Exception();
				if (primitive is FieldObject fieldObj && fieldObj.IsDerivedFromBase)
				{
					const string MESSAGE_ERROR = "Cannot serialize as the field " +
						"type doesn't match the object type. This is typically " +
						"caused as the primitive value is derived off of object " +
						"in an XML Attribute, unable to write the derived attribute " +
						"type.";
					config.Logger?.InvokeMessage(SOURCE_WRITER, MESSAGE_ERROR);
					throw new Exception(MESSAGE_ERROR);
				}
				if (XmlNamedAsAttribute.HasName(primitive, out string namedAs))
				{
					parent.RemoveChild(currentNode);
					currentNode = CreateAttribute(parent, namedAs, "");
					config.Logger?.InvokeMessage(SOURCE_WRITER, $"{StartLogObject(primitive)} is renamed to '{namedAs}', as having the {nameof(XmlNamedAsAttribute)} attribute");
				}
				currentNode.Value = ToStringPrimitive(primitive.Value);
				return true;
			}
			config.Logger?.InvokeMessage(SOURCE_WRITER, $"{StartLogObject(primitive)} is a {primitive.ValueType}, serializing primitive..");
			currentNode.InnerText = ToStringPrimitive(primitive.Value);
			return true;
		}
		private string ToStringPrimitive(object value)
		{
			if (value is IFormattable formattable)
				return formattable.ToString(null, config.CurrentCulture);
			return value.ToString();
		}
		internal bool TryWriteEnumerable(string name, StructuredObject values, XmlNode parent)
		{
			if (XMLIgnoreEnumerableAttribute.Ignore(values))
			{
				config.Logger?.InvokeMessage(SOURCE_WRITER, $"{StartLogObject(values)} may be an enumerable, but not serialize as one due to {nameof(XMLIgnoreEnumerableAttribute)} being present");
				return false;
			}
			if (values.ValueType.IsArray)
			{
				XmlElement arrayElement = CreateElement(parent, name, values);
				Array arrValue = (Array)values.Value;
				Type elementType = values.ValueType.GetElementType();
				config.Logger?.InvokeMessage(SOURCE_WRITER, $"Serializing {StartLogObject(values)} as an array with {arrValue.Length} elements..");
				for (int i = 0; i < arrValue.Length; i++)
				{
					StructuredObject currentValue = new EnumeratedObject(arrValue.GetValue(i), elementType);
					WriteObject(currentValue, arrayElement, "Item");
				}
				return true;
			}
			object value = values.Value;
			if (value is IEnumerable enumerable)
			{
				config.Logger?.InvokeMessage(SOURCE_WRITER, $"Serializing {StartLogObject(values)} as an ordinary enumerable..");
				EnsureParameterlessConstructor(values.ValueType);
				XmlElement enumerableElement = CreateElement(parent, name, values);
				Type elementType = values.ValueType.GetGenericArguments()[0];
				IEnumerator enumerator = enumerable.GetEnumerator();
				while (enumerator.MoveNext())
				{
					StructuredObject currentValue = new EnumeratedObject(enumerator.Current, elementType);
					WriteObject(currentValue, enumerableElement, "Item");
				}
				try { enumerator.Reset(); } catch { }
				return true;
			}
			return false;
		}




		public XmlElement CreateElement(XmlNode parent, string name, StructuredObject obj)
		{
			XmlElement element = CreateElement(parent, name);
			WriteTypeAttribute(element, obj);
			AddReferenceType(obj, element);
			return element;
		}
		public XmlElement CreateElement(XmlNode parent, string elementName)
		{
			XmlElement element = Document.CreateElement(elementName);
			(parent ?? Document).AppendChild(element);
			return element;
		}
		public XmlAttribute CreateAttribute(XmlNode parent, string name, string value)
		{
			XmlAttribute attribute = Document.CreateAttribute(name);
			attribute.Value = value;
			parent.Attributes.Append(attribute);
			return attribute;
		}
		public XmlAttribute WriteTypeAttribute(XmlNode parent, StructuredObject obj)
		{
			if (Config.TypeHandling == IncludeTypes.AlwaysIncludeTypes)
			{
				return CreateAttribute(parent, OVSXmlSerializer.ATTRIBUTE, obj.ValueType.FullName);
			}
			if (Config.TypeHandling == IncludeTypes.SmartTypes)
				if (obj.IsDerivedFromBase)
				{
					return CreateAttribute(parent, OVSXmlSerializer.ATTRIBUTE, obj.ValueType.FullName);
				}
			return null;
		}
		//internal bool AddReferenceType(StructuredObject obj, XmlElement representingNode)
		//{
		//	Referencer.AddReference(obj, representingNode);
		//	return true;
		//}
	}
}
